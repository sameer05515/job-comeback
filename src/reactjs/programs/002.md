> What is the console output of below program
> 
> ```js
> import React from "react";
> 
> export default function App() {
>   const [count, setCount] = React.useState(0);
>   React.useEffect(() => {
>     console.log("effect runs");
>     return () => {
>       console.log("Cleanup runs");
>     };
>   }, [count]);
> 
>   return <button onClick={() => setCount(count + 1)}>Click</button>;
> }
> ```


If you run that React code, here’s the console sequence:

---

### **On first render (mount)**

1. `"effect runs"` → because the `useEffect` runs after the initial render.

---

### **When you click the button**

* The `count` changes (`0 → 1`), so the effect’s dependency `[count]` changes.
  React will:

1. Run the cleanup of the **previous** effect: `"Cleanup runs"`.
2. Run the effect again: `"effect runs"`.

---

### **If you click again**

The same two-step sequence repeats:

* `"Cleanup runs"`
* `"effect runs"`

---

### **When the component unmounts**

* `"Cleanup runs"` one final time.

---

#### **Example Console Output**

```plaintext
effect runs
Cleanup runs
effect runs
Cleanup runs
effect runs
... (on further clicks)
Cleanup runs (on final unmount)
```

---

If you want, I can also explain **why the cleanup runs before each re-run** — it’s one of the most common React interview traps.
